function[gamma, thresh, alpha, final_fit_stat] = Fit_Gun_Luminance_Curve(raw_data, rgb)

% PART 1: Extract the data from the relevant gun
switch rgb
    case 'r',
        test_col = 1;
    case 'g',
        test_col = 2;
    case 'b',
        test_col = 3;
end

i = 1;

for row = 1:size(raw_data,1),

    if ( sum( raw_data(row,(1:3)) )==raw_data(row,test_col) ),
        % Then the sum across all gun columns equals the test column
        % This implies that only the test column has any value
        % NOTE each data set gets all three 0,0,0 entries, slick huh!
        
        Raw_Gun_Vals(i) = raw_data(row, test_col);    % The gun value
        Raw_Lum_Data(i) = raw_data(row, 4);   % The luminance data
        i = i + 1;
    end % if then test
     
    
end % for loop


% PART 2: Preprocessing: basically just average redundant data points
% Strategy? Brute force
% Loop through list, make a table of gun values
% each entry, check whether it is already in the table, if so average 

% Seed the process
Gun_Vals(1) = Raw_Gun_Vals(1);
Lum_Data{1} = [Raw_Lum_Data(1), 1];      % each entry in CA is a vector, first element of vect is a sum of lum values
                                    % second element is a count of the number of entries

for index = 2:(i-1),
    
    current_gun_val = Raw_Gun_Vals(index);
    current_lum_data = Raw_Lum_Data(index);
    
    keep_checking = 1;
    check_index = 1;
  
    while (keep_checking)
        
        if ( current_gun_val == Gun_Vals(check_index) )
            % This means that we already have an entry for this gun value
            % Thus average current_lum_data with the other data points from this gun value
            % and stop checking through Gun_Vals
            
            temp_vect = Lum_Data{check_index};
            temp_vect(1) = temp_vect(1) + Raw_Lum_Data(index);
            temp_vect(2) = temp_vect(2) + 1;
            
            Lum_Data{check_index} = temp_vect;
            
            keep_checking = 0;
            
        
        elseif (check_index < length(Gun_Vals))  
            % THen we aren't done yet, increase the check_index
            check_index = check_index + 1;
            
        else
            % THen we need to add a new entry and it is then time to stop checking
            
            check_index = check_index + 1;
            Gun_Vals(check_index) = current_gun_val;
            Lum_Data{check_index} = [current_lum_data, 1];
            
            keep_checking = 0;
        end     % if then
            
        
    end     % while loop through Gun_Vals
    
    
end     % for loop


% Now set up for fitting
Auxillary_Info = Gun_Vals;

for j = 1:length(Gun_Vals),
    
    temp_vect = Lum_Data{j};
    Data(j) = temp_vect(1) / temp_vect(2);
    
end 



% PART 3: Fit the sucka 

%params = [gamma, offset, alpha]

In_Params = [2.5, 30, max(Data)];
Min_Step_Sizes = [0.01, 1, 0.1];
Max_Step_Sizes = [0.2, 5, 1];

% TO set the tolerance I will find the TS score generated by the initial parameters
[model_out] = Model(In_Params, Auxillary_Info);
Initial_TS = FitStat(model_out, Data, Auxillary_Info);

Tol = 0.001 * Initial_TS;
Mode = 'Fixed';
%Mode = 'Adapt';                 % Use adaptive change of step sizes
V = 1;                          % Verbose flag


[final_params, final_fit_stat, num] = FitUtil(In_Params, Min_Step_Sizes, Max_Step_Sizes, Tol, Mode, Auxillary_Info, Data, V);

gamma = final_params(1);
thresh = final_params(2);
alpha = final_params(3);